# Create a ZIP with a CI/CD pipeline for a full-stack project (GitHub Actions + Docker + k8s manifests + helper scripts)
import os, textwrap, zipfile, json
BASE = "/mnt/data/ci-cd-pipeline"
os.makedirs(BASE, exist_ok=True)

def write(path, content):
    full = os.path.join(BASE, path)
    os.makedirs(os.path.dirname(full), exist_ok=True)
    with open(full, "w", encoding="utf-8") as f:
        f.write(content)

# README
write("README.md", textwrap.dedent("""\
# CI/CD Pipeline for Full-Stack Project

This repository contains a ready-made CI/CD pipeline for a full-stack (frontend + backend) project using:
- GitHub Actions workflows
- Dockerfiles for frontend and backend
- Kubernetes manifests for deployment
- Helper deployment scripts

**How to use**
1. Copy the Dockerfiles and k8s manifests into your repository root or adapt paths.
2. Set GitHub Secrets in your repository:
   - DOCKER_USERNAME
   - DOCKER_PASSWORD
   - DOCKER_REGISTRY_HOST (optional, default docker.io)
   - KUBE_CONFIG_DATA (base64 encoded kubeconfig for the target cluster)
   - K8S_NAMESPACE (optional)
3. Push to `main` — the workflow will run CI on PR/push and deploy on push to `main`.

Files included:
- .github/workflows/ci-cd.yml  (main workflow)
- backend/Dockerfile
- frontend/Dockerfile
- k8s/backend-deployment.yaml
- k8s/backend-service.yaml
- k8s/frontend-deployment.yaml
- k8s/frontend-service.yaml
- k8s/ingress.yaml
- scripts/deploy-local.sh
- scripts/build-and-push.sh
"""))

# GitHub Actions workflow
write(".github/workflows/ci-cd.yml", textwrap.dedent("""\
name: CI → CD (Frontend + Backend)

on:
  push:
    branches: [ "**" ]
  pull_request:
    branches: [ "**" ]

jobs:
  backend-ci:
    name: Backend — CI (lint & test)
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: backend
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Use Node.js 18
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install backend dependencies
        run: npm ci

      - name: Run backend lint
        run: npm run lint || true

      - name: Run backend tests
        run: npm test || true

  frontend-ci:
    name: Frontend — CI (lint & test)
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: frontend
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Use Node.js 18
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install frontend dependencies
        run: npm ci

      - name: Run frontend lint
        run: npm run lint || true

      - name: Run frontend tests
        run: npm test || true

  build-and-push:
    name: Build & Push Docker Images
    runs-on: ubuntu-latest
    needs: [backend-ci, frontend-ci]
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Log in to Docker registry
        uses: docker/login-action@v2
        with:
          registry: ${{ secrets.DOCKER_REGISTRY_HOST || 'docker.io' }}
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build & push backend image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKER_REGISTRY_HOST || 'docker.io' }}/${{ secrets.DOCKER_USERNAME }}/app-backend:${{ github.sha }}
            ${{ secrets.DOCKER_REGISTRY_HOST || 'docker.io' }}/${{ secrets.DOCKER_USERNAME }}/app-backend:latest

      - name: Build & push frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKER_REGISTRY_HOST || 'docker.io' }}/${{ secrets.DOCKER_USERNAME }}/app-frontend:${{ github.sha }}
            ${{ secrets.DOCKER_REGISTRY_HOST || 'docker.io' }}/${{ secrets.DOCKER_USERNAME }}/app-frontend:latest

  deploy-to-k8s:
    name: Deploy → Kubernetes
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.30.0'

      - name: Configure kubeconfig
        env:
          KUBECONFIG_DATA: ${{ secrets.KUBE_CONFIG_DATA }}
        run: |
          if [ -z "$KUBECONFIG_DATA" ]; then
            echo "KUBE_CONFIG_DATA secret is not set. Aborting."
            exit 1
          fi
          echo "$KUBECONFIG_DATA" | base64 --decode > kubeconfig
          export KUBECONFIG="$PWD/kubeconfig"
          kubectl config view

      - name: Deploy manifests (apply)
        env:
          KUBECONFIG: ${{ github.workspace }}/kubeconfig
        run: |
          REGISTRY=${{ secrets.DOCKER_REGISTRY_HOST || 'docker.io' }}
          USER=${{ secrets.DOCKER_USERNAME }}
          BACKEND_IMAGE="$REGISTRY/$USER/app-backend:${{ github.sha }}"
          FRONTEND_IMAGE="$REGISTRY/$USER/app-frontend:${{ github.sha }}"
          echo "Using backend image: $BACKEND_IMAGE"
          echo "Using frontend image: $FRONTEND_IMAGE"

          kubectl -n ${K8S_NAMESPACE:-default} apply -f k8s/backend-deployment.yaml --dry-run=client -o yaml \
            | sed "s|__BACKEND_IMAGE__|$BACKEND_IMAGE|g" \
            | kubectl apply -f -

          kubectl -n ${K8S_NAMESPACE:-default} apply -f k8s/frontend-deployment.yaml --dry-run=client -o yaml \
            | sed "s|__FRONTEND_IMAGE__|$FRONTEND_IMAGE|g" \
            | kubectl apply -f -

          kubectl -n ${K8S_NAMESPACE:-default} apply -f k8s/backend-service.yaml
          kubectl -n ${K8S_NAMESPACE:-default} apply -f k8s/frontend-service.yaml
          kubectl -n ${K8S_NAMESPACE:-default} apply -f k8s/ingress.yaml || true

      - name: Wait for rollouts
        env:
          KUBECONFIG: ${{ github.workspace }}/kubeconfig
        run: |
          kubectl rollout status deployment/app-backend -n ${K8S_NAMESPACE:-default} --timeout=120s || true
          kubectl rollout status deployment/app-frontend -n ${K8S_NAMESPACE:-default} --timeout=120s || true
"""))

# Dockerfiles
write("backend/Dockerfile", textwrap.dedent("""\
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build || true

FROM node:18-alpine
WORKDIR /app
ENV NODE_ENV=production
RUN addgroup -S app && adduser -S -G app app
COPY --from=builder /app/package*.json ./
RUN npm ci --production=true
COPY --from=builder /app ./
USER app
EXPOSE 5000
CMD ["node", "server.js"]
"""))

write("frontend/Dockerfile", textwrap.dedent("""\
FROM node:18-alpine AS build
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM nginx:stable-alpine
COPY --from=build /app/build /usr/share/nginx/html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
"""))

# k8s manifests
write("k8s/backend-deployment.yaml", textwrap.dedent("""\
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app-backend
spec:
  replicas: 2
  selector:
    matchLabels:
      app: app-backend
  template:
    metadata:
      labels:
        app: app-backend
    spec:
      containers:
        - name: backend
          image: __BACKEND_IMAGE__
          imagePullPolicy: Always
          ports:
            - containerPort: 5000
          readinessProbe:
            httpGet:
              path: /health
              port: 5000
            initialDelaySeconds: 5
            periodSeconds: 10
"""))

write("k8s/backend-service.yaml", textwrap.dedent("""\
apiVersion: v1
kind: Service
metadata:
  name: app-backend
spec:
  selector:
    app: app-backend
  ports:
    - protocol: TCP
      port: 5000
      targetPort: 5000
  type: ClusterIP
"""))

write("k8s/frontend-deployment.yaml", textwrap.dedent("""\
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app-frontend
spec:
  replicas: 2
  selector:
    matchLabels:
      app: app-frontend
  template:
    metadata:
      labels:
        app: app-frontend
    spec:
      containers:
        - name: frontend
          image: __FRONTEND_IMAGE__
          imagePullPolicy: Always
          ports:
            - containerPort: 80
          readinessProbe:
            httpGet:
              path: /
              port: 80
            initialDelaySeconds: 5
            periodSeconds: 10
"""))

write("k8s/frontend-service.yaml", textwrap.dedent("""\
apiVersion: v1
kind: Service
metadata:
  name: app-frontend
spec:
  selector:
    app: app-frontend
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
  type: LoadBalancer
"""))

write("k8s/ingress.yaml", textwrap.dedent("""\
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: app-ingress
  annotations:
    kubernetes.io/ingress.class: "nginx"
spec:
  rules:
    - host: example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: app-frontend
                port:
                  number: 80
          - path: /api
            pathType: Prefix
            backend:
              service:
                name: app-backend
                port:
                  number: 5000
"""))

# helper scripts
write("scripts/deploy-local.sh", textwrap.dedent("""\
#!/usr/bin/env bash
set -euo pipefail
REGISTRY=${1:-docker.io/youruser}
SHA=${2:-latest}
NAMESPACE=${3:-default}

echo "Deploying to namespace: $NAMESPACE with images tagged: $SHA"

kubectl -n $NAMESPACE apply -f k8s/backend-service.yaml
sed \"s|__BACKEND_IMAGE__|$REGISTRY/youruser/app-backend:$SHA|g\" k8s/backend-deployment.yaml | kubectl -n $NAMESPACE apply -f -
sed \"s|__FRONTEND_IMAGE__|$REGISTRY/youruser/app-frontend:$SHA|g\" k8s/frontend-deployment.yaml | kubectl -n $NAMESPACE apply -f -
kubectl -n $NAMESPACE rollout status deployment/app-backend
kubectl -n $NAMESPACE rollout status deployment/app-frontend
"""))

write("scripts/build-and-push.sh", textwrap.dedent("""\
#!/usr/bin/env bash
set -euo pipefail
REGISTRY=${1:-docker.io}
USER=${2:-youruser}
SHA=${3:-latest}

docker build -t $REGISTRY/$USER/app-backend:$SHA -f backend/Dockerfile backend
docker build -t $REGISTRY/$USER/app-frontend:$SHA -f frontend/Dockerfile frontend

docker push $REGISTRY/$USER/app-backend:$SHA
docker push $REGISTRY/$USER/app-frontend:$SHA
"""))

# .env.example for CI secrets explanation
write(".env.example", textwrap.dedent("""\
# For local reference only - DO NOT commit secrets.
# In GitHub repo settings -> Secrets, set these:
# DOCKER_USERNAME, DOCKER_PASSWORD, DOCKER_REGISTRY_HOST (optional), KUBE_CONFIG_DATA (base64 kubeconfig), K8S_NAMESPACE (optional)
"""))

# Create zip
zip_path = "/mnt/data/ci-cd-pipeline.zip"
with zipfile.ZipFile(zip_path, "w", zipfile.ZIP_DEFLATED) as zf:
    for root, dirs, files in os.walk(BASE):
        for file in files:
            full = os.path.join(root, file)
            arc = os.path.relpath(full, BASE)
            zf.write(full, arc)

zip_path

