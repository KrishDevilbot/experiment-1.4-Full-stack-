// ==========================================
// server.js - Main Application Entry Point
// ==========================================

const express = require('express');
const mongoose = require('mongoose');
const dotenv = require('dotenv');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');

// Load environment variables
dotenv.config();

// Initialize Express
const app = express();

// ==========================================
// MIDDLEWARE
// ==========================================

// Security middleware
app.use(helmet()); // Adds security headers
app.use(cors({
    origin: process.env.FRONTEND_URL || 'http://localhost:3000',
    credentials: true
}));

// Rate limiting to prevent brute force attacks
const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // Limit each IP to 100 requests per windowMs
    message: 'Too many requests from this IP, please try again later.'
});
app.use('/api/', limiter);

// Body parsing
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// ==========================================
// DATABASE CONNECTION
// ==========================================

mongoose.connect(process.env.MONGO_URI, {
    useNewUrlParser: true,
    useUnifiedTopology: true
})
.then(() => console.log('✅ MongoDB Connected Successfully'))
.catch(err => console.error('❌ MongoDB Connection Error:', err));

// ==========================================
// ROUTES
// ==========================================

const authRoutes = require('./routes/authRoutes');
const accountRoutes = require('./routes/accountRoutes');
const transactionRoutes = require('./routes/transactionRoutes');

app.use('/api/auth', authRoutes);
app.use('/api/accounts', accountRoutes);
app.use('/api/transactions', transactionRoutes);

// Home route
app.get('/', (req, res) => {
    res.json({
        message: '🏦 Secure Banking API',
        version: '1.0.0',
        endpoints: {
            auth: '/api/auth',
            accounts: '/api/accounts',
            transactions: '/api/transactions'
        }
    });
});

// 404 Handler
app.use((req, res) => {
    res.status(404).json({ error: 'Route not found' });
});

// Error Handler
app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(500).json({ 
        error: 'Internal Server Error',
        message: process.env.NODE_ENV === 'development' ? err.message : undefined
    });
});

// Start Server
const PORT = process.env.PORT || 5000;
app.listen(PORT, () => {
    console.log(`🚀 Banking API Server running on port ${PORT}`);
});

// ==========================================
// models/User.js - User Model
// ==========================================

const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const userSchema = new mongoose.Schema({
    username: {
        type: String,
        required: [true, 'Username is required'],
        unique: true,
        trim: true,
        minlength: 3
    },
    email: {
        type: String,
        required: [true, 'Email is required'],
        unique: true,
        lowercase: true,
        match: [/^\S+@\S+\.\S+$/, 'Please enter a valid email']
    },
    password: {
        type: String,
        required: [true, 'Password is required'],
        minlength: 6,
        select: false // Don't return password by default
    },
    role: {
        type: String,
        enum: ['customer', 'admin', 'manager'],
        default: 'customer'
    },
    isActive: {
        type: Boolean,
        default: true
    },
    phoneNumber: {
        type: String,
        required: true
    },
    address: {
        street: String,
        city: String,
        state: String,
        zipCode: String,
        country: String
    },
    createdAt: {
        type: Date,
        default: Date.now
    },
    lastLogin: {
        type: Date
    },
    failedLoginAttempts: {
        type: Number,
        default: 0
    },
    accountLocked: {
        type: Boolean,
        default: false
    },
    lockUntil: Date
});

// Hash password before saving
userSchema.pre('save', async function(next) {
    if (!this.isModified('password')) return next();
    
    try {
        const salt = await bcrypt.genSalt(10);
        this.password = await bcrypt.hash(this.password, salt);
        next();
    } catch (error) {
        next(error);
    }
});

// Method to compare passwords
userSchema.methods.comparePassword = async function(candidatePassword) {
    return await bcrypt.compare(candidatePassword, this.password);
};

// Method to check if account is locked
userSchema.methods.isLocked = function() {
    return !!(this.accountLocked && this.lockUntil && this.lockUntil > Date.now());
};

module.exports = mongoose.model('User', userSchema);

// ==========================================
// models/Account.js - Bank Account Model
// ==========================================

const accountSchema = new mongoose.Schema({
    accountNumber: {
        type: String,
        required: true,
        unique: true,
        default: () => 'ACC' + Date.now() + Math.random().toString(36).substr(2, 9).toUpperCase()
    },
    userId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: true
    },
    accountType: {
        type: String,
        enum: ['savings', 'checking', 'business'],
        default: 'savings'
    },
    balance: {
        type: Number,
        default: 0,
        min: 0
    },
    currency: {
        type: String,
        default: 'USD'
    },
    status: {
        type: String,
        enum: ['active', 'frozen', 'closed'],
        default: 'active'
    },
    overdraftLimit: {
        type: Number,
        default: 0
    },
    interestRate: {
        type: Number,
        default: 0
    },
    createdAt: {
        type: Date,
        default: Date.now
    },
    lastTransaction: {
        type: Date
    }
});

module.exports = mongoose.model('Account', accountSchema);

// ==========================================
// models/Transaction.js - Transaction Model
// ==========================================

const transactionSchema = new mongoose.Schema({
    transactionId: {
        type: String,
        unique: true,
        default: () => 'TXN' + Date.now() + Math.random().toString(36).substr(2, 9).toUpperCase()
    },
    fromAccount: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Account',
        required: true
    },
    toAccount: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Account'
    },
    amount: {
        type: Number,
        required: true,
        min: 0
    },
    type: {
        type: String,
        enum: ['deposit', 'withdrawal', 'transfer', 'payment'],
        required: true
    },
    status: {
        type: String,
        enum: ['pending', 'completed', 'failed', 'cancelled'],
        default: 'pending'
    },
    description: {
        type: String,
        maxlength: 500
    },
    initiatedBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: true
    },
    timestamp: {
        type: Date,
        default: Date.now
    },
    balanceAfter: {
        type: Number
    },
    metadata: {
        ipAddress: String,
        userAgent: String,
        location: String
    }
});

module.exports = mongoose.model('Transaction', transactionSchema);

// ==========================================
// middleware/auth.js - JWT Authentication
// ==========================================

const jwt = require('jsonwebtoken');
const User = require('../models/User');

// Verify JWT Token
exports.protect = async (req, res, next) => {
    let token;

    // Check for token in headers
    if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
        token = req.headers.authorization.split(' ')[1];
    }

    // Check if token exists
    if (!token) {
        return res.status(401).json({ 
            error: 'Not authorized, no token provided' 
        });
    }

    try {
        // Verify token
        const decoded = jwt.verify(token, process.env.JWT_SECRET);

        // Get user from token
        req.user = await User.findById(decoded.id).select('-password');

        if (!req.user) {
            return res.status(401).json({ error: 'User not found' });
        }

        if (!req.user.isActive) {
            return res.status(401).json({ error: 'Account is deactivated' });
        }

        if (req.user.isLocked()) {
            return res.status(401).json({ error: 'Account is locked' });
        }

        next();
    } catch (error) {
        console.error('Token verification error:', error);
        return res.status(401).json({ error: 'Not authorized, invalid token' });
    }
};

// Generate JWT Token
exports.generateToken = (id) => {
    return jwt.sign({ id }, process.env.JWT_SECRET, {
        expiresIn: process.env.JWT_EXPIRE || '24h'
    });
};

// Refresh Token
exports.generateRefreshToken = (id) => {
    return jwt.sign({ id }, process.env.JWT_REFRESH_SECRET, {
        expiresIn: '7d'
    });
};

// ==========================================
// middleware/authorization.js - Role-Based Access
// ==========================================

exports.authorize = (...roles) => {
    return (req, res, next) => {
        if (!req.user) {
            return res.status(401).json({ error: 'Not authenticated' });
        }

        if (!roles.includes(req.user.role)) {
            return res.status(403).json({ 
                error: `Role '${req.user.role}' is not authorized to access this resource` 
            });
        }

        next();
    };
};

// Check account ownership or admin
exports.checkAccountOwnership = async (req, res, next) => {
    try {
        const Account = require('../models/Account');
        const account = await Account.findById(req.params.id);

        if (!account) {
            return res.status(404).json({ error: 'Account not found' });
        }

        // Allow if user is admin or account owner
        if (req.user.role === 'admin' || account.userId.toString() === req.user._id.toString()) {
            req.account = account;
            next();
        } else {
            return res.status(403).json({ error: 'Not authorized to access this account' });
        }
    } catch (error) {
        return res.status(500).json({ error: 'Server error' });
    }
};

// ==========================================
// controllers/authController.js
// ==========================================

const User = require('../models/User');
const { generateToken, generateRefreshToken } = require('../middleware/auth');
const { validationResult } = require('express-validator');

// Register new user
exports.register = async (req, res) => {
    try {
        const errors = validationResult(req);
        if (!errors.isEmpty()) {
            return res.status(400).json({ errors: errors.array() });
        }

        const { username, email, password, phoneNumber, address } = req.body;

        // Check if user already exists
        const existingUser = await User.findOne({ $or: [{ email }, { username }] });
        if (existingUser) {
            return res.status(400).json({ error: 'User already exists' });
        }

        // Create user
        const user = await User.create({
            username,
            email,
            password,
            phoneNumber,
            address
        });

        // Generate tokens
        const token = generateToken(user._id);
        const refreshToken = generateRefreshToken(user._id);

        res.status(201).json({
            success: true,
            message: 'User registered successfully',
            token,
            refreshToken,
            user: {
                id: user._id,
                username: user.username,
                email: user.email,
                role: user.role
            }
        });
    } catch (error) {
        console.error('Registration error:', error);
        res.status(500).json({ error: 'Server error during registration' });
    }
};

// Login user
exports.login = async (req, res) => {
    try {
        const { email, password } = req.body;

        // Validate input
        if (!email || !password) {
            return res.status(400).json({ error: 'Please provide email and password' });
        }

        // Find user with password field
        const user = await User.findOne({ email }).select('+password');

        if (!user) {
            return res.status(401).json({ error: 'Invalid credentials' });
        }

        // Check if account is locked
        if (user.isLocked()) {
            return res.status(401).json({ 
                error: 'Account is locked. Please try again later.' 
            });
        }

        // Verify password
        const isPasswordMatch = await user.comparePassword(password);

        if (!isPasswordMatch) {
            // Increment failed login attempts
            user.failedLoginAttempts += 1;

            // Lock account after 5 failed attempts
            if (user.failedLoginAttempts >= 5) {
                user.accountLocked = true;
                user.lockUntil = Date.now() + 30 * 60 * 1000; // Lock for 30 minutes
            }

            await user.save();
            return res.status(401).json({ error: 'Invalid credentials' });
        }

        // Reset failed attempts on successful login
        user.failedLoginAttempts = 0;
        user.accountLocked = false;
        user.lockUntil = undefined;
        user.lastLogin = Date.now();
        await user.save();

        // Generate tokens
        const token = generateToken(user._id);
        const refreshToken = generateRefreshToken(user._id);

        res.json({
            success: true,
            message: 'Login successful',
            token,
            refreshToken,
            user: {
                id: user._id,
                username: user.username,
                email: user.email,
                role: user.role
            }
        });
    } catch (error) {
        console.error('Login error:', error);
        res.status(500).json({ error: 'Server error during login' });
    }
};

// Get current user
exports.getMe = async (req, res) => {
    try {
        const user = await User.findById(req.user._id);
        res.json({ success: true, user });
    } catch (error) {
        res.status(500).json({ error: 'Server error' });
    }
};

// Logout
exports.logout = (req, res) => {
    // In a real application, you would invalidate the token
    // For JWT, typically handled on client-side by removing token
    res.json({ success: true, message: 'Logged out successfully' });
};

// ==========================================
// controllers/accountController.js
// ==========================================

const Account = require('../models/Account');

// Create new account
exports.createAccount = async (req, res) => {
    try {
        const { accountType, initialDeposit } = req.body;

        const account = await Account.create({
            userId: req.user._id,
            accountType,
            balance: initialDeposit || 0
        });

        res.status(201).json({
            success: true,
            message: 'Account created successfully',
            account
        });
    } catch (error) {
        console.error('Account creation error:', error);
        res.status(500).json({ error: 'Failed to create account' });
    }
};

// Get all accounts for user
exports.getMyAccounts = async (req, res) => {
    try {
        const accounts = await Account.find({ userId: req.user._id });
        res.json({ success: true, count: accounts.length, accounts });
    } catch (error) {
        res.status(500).json({ error: 'Server error' });
    }
};

// Get account by ID
exports.getAccount = async (req, res) => {
    try {
        const account = req.account; // From middleware
        res.json({ success: true, account });
    } catch (error) {
        res.status(500).json({ error: 'Server error' });
    }
};

// Get account balance
exports.getBalance = async (req, res) => {
    try {
        const account = req.account;
        res.json({ 
            success: true, 
            accountNumber: account.accountNumber,
            balance: account.balance,
            currency: account.currency
        });
    } catch (error) {
        res.status(500).json({ error: 'Server error' });
    }
};

// ==========================================
// controllers/transactionController.js
// ==========================================

const Transaction = require('../models/Transaction');

// Deposit money
exports.deposit = async (req, res) => {
    try {
        const { accountId, amount, description } = req.body;

        if (amount <= 0) {
            return res.status(400).json({ error: 'Amount must be greater than 0' });
        }

        const account = await Account.findById(accountId);
        if (!account || account.userId.toString() !== req.user._id.toString()) {
            return res.status(404).json({ error: 'Account not found' });
        }

        // Update balance
        account.balance += amount;
        account.lastTransaction = Date.now();
        await account.save();

        // Create transaction record
        const transaction = await Transaction.create({
            fromAccount: accountId,
            amount,
            type: 'deposit',
            status: 'completed',
            description,
            initiatedBy: req.user._id,
            balanceAfter: account.balance
        });

        res.json({
            success: true,
            message: 'Deposit successful',
            transaction,
            newBalance: account.balance
        });
    } catch (error) {
        console.error('Deposit error:', error);
        res.status(500).json({ error: 'Transaction failed' });
    }
};

// Withdraw money
exports.withdraw = async (req, res) => {
    try {
        const { accountId, amount, description } = req.body;

        if (amount <= 0) {
            return res.status(400).json({ error: 'Amount must be greater than 0' });
        }

        const account = await Account.findById(accountId);
        if (!account || account.userId.toString() !== req.user._id.toString()) {
            return res.status(404).json({ error: 'Account not found' });
        }

        // Check sufficient balance
        if (account.balance < amount) {
            return res.status(400).json({ error: 'Insufficient funds' });
        }

        // Update balance
        account.balance -= amount;
        account.lastTransaction = Date.now();
        await account.save();

        // Create transaction record
        const transaction = await Transaction.create({
            fromAccount: accountId,
            amount,
            type: 'withdrawal',
            status: 'completed',
            description,
            initiatedBy: req.user._id,
            balanceAfter: account.balance
        });

        res.json({
            success: true,
            message: 'Withdrawal successful',
            transaction,
            newBalance: account.balance
        });
    } catch (error) {
        console.error('Withdrawal error:', error);
        res.status(500).json({ error: 'Transaction failed' });
    }
};

// Transfer money
exports.transfer = async (req, res) => {
    try {
        const { fromAccountId, toAccountNumber, amount, description } = req.body;

        if (amount <= 0) {
            return res.status(400).json({ error: 'Amount must be greater than 0' });
        }

        // Get sender account
        const fromAccount = await Account.findById(fromAccountId);
        if (!fromAccount || fromAccount.userId.toString() !== req.user._id.toString()) {
            return res.status(404).json({ error: 'Source account not found' });
        }

        // Get recipient account
        const toAccount = await Account.findOne({ accountNumber: toAccountNumber });
        if (!toAccount) {
            return res.status(404).json({ error: 'Recipient account not found' });
        }

        // Check sufficient balance
        if (fromAccount.balance < amount) {
            return res.status(400).json({ error: 'Insufficient funds' });
        }

        // Perform transfer
        fromAccount.balance -= amount;
        toAccount.balance += amount;

        fromAccount.lastTransaction = Date.now();
        toAccount.lastTransaction = Date.now();

        await fromAccount.save();
        await toAccount.save();

        // Create transaction record
        const transaction = await Transaction.create({
            fromAccount: fromAccountId,
            toAccount: toAccount._id,
            amount,
            type: 'transfer',
            status: 'completed',
            description,
            initiatedBy: req.user._id,
            balanceAfter: fromAccount.balance
        });

        res.json({
            success: true,
            message: 'Transfer successful',
            transaction,
            newBalance: fromAccount.balance
        });
    } catch (error) {
        console.error('Transfer error:', error);
        res.status(500).json({ error: 'Transaction failed' });
    }
};

// Get transaction history
exports.getTransactionHistory = async (req, res) => {
    try {
        const { accountId } = req.params;
        const { page = 1, limit = 10 } = req.query;

        const account = await Account.findById(accountId);
        if (!account || account.userId.toString() !== req.user._id.toString()) {
            return res.status(404).json({ error: 'Account not found' });
        }

        const transactions = await Transaction.find({
            $or: [{ fromAccount: accountId }, { toAccount: accountId }]
        })
        .sort({ timestamp: -1 })
        .limit(limit * 1)
        .skip((page - 1) * limit)
        .populate('initiatedBy', 'username email');

        const count = await Transaction.countDocuments({
            $or: [{ fromAccount: accountId }, { toAccount: accountId }]
        });

        res.json({
            success: true,
            transactions,
            totalPages: Math.ceil(count / limit),
            currentPage: page,
            total: count
        });
    } catch (error) {
        console.error('Transaction history error:', error);
        res.status(500).json({ error: 'Failed to fetch transactions' });
    }
};

// ==========================================
// routes/authRoutes.js
// ==========================================

const express = require('express');
const router = express.Router();
const { body } = require('express-validator');
const authController = require('../controllers/authController');
const { protect } = require('../middleware/auth');

// Validation rules
const registerValidation = [
    body('username').isLength({ min: 3 }).trim(),
    body('email').isEmail().normalizeEmail(),
    body('password').isLength({ min: 6 }),
    body('phoneNumber').isMobilePhone()
];

// Public routes
router.post('/register', registerValidation, authController.register);
router.post('/login', authController.login);

// Protected routes
router.get('/me', protect, authController.getMe);
router.post('/logout', protect, authController.logout);

module.exports = router;

// ==========================================
// routes/accountRoutes.js
// ==========================================

const router = express.Router();
const accountController = require('../controllers/accountController');
const { protect } = require('../middleware/auth');
const { checkAccountOwnership } = require('../middleware/authorization');

// All routes are protected
router.use(protect);

router.post('/', accountController.createAccount);
router.get('/my-accounts', accountController.getMyAccounts);
router.get('/:id', checkAccountOwnership, accountController.getAccount);
router.get('/:id/balance', checkAccountOwnership, accountController.getBalance);

module.exports = router;

// ==========================================
// routes/transactionRoutes.js
// ==========================================

const router = express.Router();
const transactionController = require('../controllers/transactionController');
const { protect } = require('../middleware/auth');

// All routes are protected
router.use(protect);

router.post('/deposit', transactionController.deposit);
router.post('/withdraw', transactionController.withdraw);
router.post('/transfer', transactionController.transfer);
router.get('/history/:accountId', transactionController.getTransactionHistory);

module.exports = router;
